1- D. No terminal operation is called, so the stream never executes. The methods chain to create a stream that would contain â€œ2â€� and â€œ12.â€� The first line creates an infinite stream. The second line would get the first two elements from that infinite stream and map each element to add an extra character. 
2- F. b1 is set to true since anyMatch() terminates. Even though the stream is infinite, Java finds a match on the first element and stops looking. However, when allMatch() runs, it needs to keep going until the end of the stream since it keeps finding matches. Since all elements continue to match, the program hangs. 
3- E. An infinite stream is generated where each element is twice as long as the previous one. b1 is set to false because Java finds an element that doesnâ€™t match when it gets to the element of length 4. However, the next line tries to operate on the same stream. Since streams can be used only once, this throws an exception that the â€œstream has already been operated upon or closed.â€� If two different streams were used, the result would be option A. 
4- A, B. Terminal operations are the final step in a stream pipeline. Exactly one is required, because it triggers the execution of the entire stream pipeline. Therefore, options A and B are correct. Options C and F are true of intermediate operations rather than terminal operations. Option E is never true. Once a stream pipeline is run, the Stream is marked invalid. 
5- A, B. Options D and E are incorrect because they are intermediate operations and not terminal operations. While option F is a reduction, it is incorrect because it is available only on primitive streams such as IntStream. Option C is incorrect because it is not a reductionâ€”it does not look at each element in the stream. 
6- A. Options C and D are incorrect because these methods do not take a Predicate parameter and do not return a boolean. Options B and E are incorrect because they cause the code to run infinitely. The stream has no way to know that a match wonâ€™t show up later. Option A is correct because it is safe to return false as soon as one element passes through the stream that doesnâ€™t match. 
7- F. The sorted() method is used in a stream pipeline to return a sorted Stream. A collector is needed to turn the stream back into a List. The collect() method takes the desired collector. 
8- D, E. The sum() method returns an int rather than an OptionalInt because the sum of an empty list is zero. Therefore, option E is correct. The findAny() method returns an OptionalInt because there might not be any elements to find. Therefore, option D is correct. The average() method returns an OptionalDouble since averages of any type can result in a fraction. Therefore, options A and B are both incorrect. 
9- B, D. Option A would work for a regular Stream. However, we have a LongStream and therefore need to call getAsLong(). Option C is missing the :: that would make it a method reference. Therefore, options B and D are correct. 
10- F. The terminal operation must be right before the semicolon, which is line M. Remember that forEach() is a terminal operation while peek() is an intermediate operation. This eliminates all but choices C, E, and F. Choice E is incorrect because there is no limit() operation, which means that the code would run infinitely. Choice C is incorrect because filter() is called before limit(). No elements make it through the filter, so the code also runs infinitely. Choice F is correct. 
11- B, C, E. As written, the code doesnâ€™t compile because the collector expects to get a String immediately before it in the chain. Option B fixes this, at which point nothing is output because the collector creates a String. Option E fixes this and causes the output to be 11111. Since the post-increment operator is used, the stream contains an infinite number of 1s. Option C fixes this and causes the stream to contain increasing numbers.
12- A, F, G. Line 6 doesnâ€™t take any parameters, and it returns a String, making it a Supplier. Another clue is that it uses a constructor reference, which should scream Supplier! This makes choice F correct. Line 7 takes two parameters, and it doesnâ€™t return anything making it a BiConsumer. The print statement should also be a clue that we are dealing with a Consumer or BiConsumer. This makes choice A correct. Choices C and D are there to mislead you; these interfaces donâ€™t actually exist. BinaryOperator spells out binary. The other functional interfaces use the prefix Bi. Finally, line 8 takes a single parameter, and it returns the same type, which is a UnaryOperator. Since the types are the same, only one generic is needed, making choice G correct. 
13- F. If the map() and flatMap() calls were reversed, choice B would be correct. In this case, the Stream created from the source is of type Stream<List<Integer>>. The Function in map expects an Integer rather than a List<Integer>, so the code does not compile. 
14- D. Line 4 should obviously look OK. It creates a Stream and uses autoboxing to put the Integer 1 inside. Line 5 converts to a primitive, again using autoboxing. Line 6 converts to a double primitive, which works since double d = 1; would work. Line 7 is where it all falls apart. Converting from a double to an int would require a cast inside the lambda. 
15- D, E. Choices A and B do not compile, because they are invalid generic declarations. Primitives are not allowed as generics, and Map must have two generic types. Choice C is incorrect because partitioning only gives a Boolean key. Choices D and E are correct because the result Collection can be customized. 
16- C. The partitioningBy() operation always returns a map with two Boolean keys, even if there are no corresponding values. By contrast, groupingBy() returns only keys that are actually needed. 
17- E. A UnaryOperator is a special type of function where the parameter and return type are the same. Therefore, option E is correct. Notice that other options donâ€™t even compile because they have the wrong number of generic types for the functional interface provided. 
18- D. The terminal operation is count(). Since there is a terminal operation, the intermediate operations run. The peek() operation comes before the filter, so both numbers are printed. The count happens to be 1 since the other number is filtered. However, the result of the stream pipeline isnâ€™t stored in a variable, and that result is ignored. 
19- A, C, E. The three common types of double, int and, long have dedicated supplier classes. The only primitive functional interface that does not involve one of those three types is BooleanSupplier. 
20- B. Both lists and streams have forEach() methods. There is no reason to collect into a list just to loop through it. 