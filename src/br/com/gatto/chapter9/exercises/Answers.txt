1- F. The code snippet will not compile due to a bug on the first and second lines. The first line should use Paths.get(), because there is no method Path.get(). The second line passes a String to relativize() instead of a Path object. If both lines were corrected to use Paths.get(), then the correct answer would be A. Remember that the normalize() method, like most methods in the Path interface, does not modify the Path object, but instead it returns a new Path object. If it was corrected to reassign the new value to the existing path variable, then E would be correct. 
2- B, C. The code snippet compiles without issue, so F is incorrect. If the value refers to a regular file, isDirectory() will return false and the statement will be skipped, so A is incorrect. Likewise, if the directory does not exist, the method also returns false, so E is also incorrect. A symbolic link can point to a real directory, and by default isDirectory() follows links, so B is possible. In this case, the symbolic link, not the directory, would be deleted. C is also possible and is the simple case of deleting an empty directory. D would allow the code to reach the execution block of the if/then statement, but the method deleteIfExists() would throw a DirectoryNotEmptyException if it had contents. 
3- D. The setTimes() method is available only on BasicFileAttributeView, not the read-only BasicFileAttributes class, so line 4 will not compile and D is correct. You need to retrieve an instance of the view class to update the data. The rest of the lines compile without issue and only D is correct. 
4- C. First off, the code compiles without issue, so G is incorrect. Let’s take this one step at a time. First, the subpath() method is applied to the absolute path, which returns the relative path animals/bear. Next, the getName() method is applied to the relative path, and since this is indexed from zero, it returns the relative path bear. Finally, the toAbsolutePath() method is applied to the relative path bear, resulting in the current directory being incorporated into the path. The final output is the absolute path /user/home/bear, so C is correct. 
5- B, C, D. The first clause of the if/then statement will be true only if the target of the symbolic link, /mammal/kangaroo, exists, since by default isDirectory() follows symbolic links, so B is correct. Option A is incorrect because /mammal/kangaroo may not exist or /mammal/kangaroo/joey may already exist. If /mammal/kangaroo does exist, then the directory will be created at /mammal/kangaroo/joey, and because the symbolic link would be accessible as /kang/joey, C and D are both correct. E is incorrect, because the code compiles without issue. F is incorrect because the code may throw an exception at runtime, such as when the file system is unavailable or locked for usage; thus it is not guaranteed to throw an exception at runtime.
6- C. The code does not compile since the stream output by Files.walk() is Stream<Path>, therefore we need a Predictate, not a BiPredicate, on line w1, and the answer is C. If the Files.find() method had been used instead, and the lambda had been passed as an argument to the method instead of on filter(), the output would be B, Has Sub-directory, since the directory is given to be empty. For fun, we reversed the expected output of the ternary operation to make sure that you understood the process. 
7- F. The code compiles without issue, so D and E are incorrect. The method Files.isSameFile() first checks to see if the Path values are the same in terms of equals(). Since the first path is relative and the second path is absolute, this comparison will return false, forcing isSameFile() to check for the existence of both paths in the file system. Since we know /zoo/turkey does not exist, a NoSuchFileException is thrown and F is the correct answer. A, B, and C are incorrect since an exception is thrown at runtime.
8- A. The code compiles and runs without issue, so E is incorrect. For this question, you have to remember two things. First, the resolve() method does not normalize any path symbols, so C and D are not correct. Second, calling resolve() with an absolute path as a parameter returns the absolute path, so A is correct and B is incorrect. 
9- B, C. The methods are not the same, because Files.lines() returns a Stream<Path> and Files.readAllLines() returns a List<String>, so F is incorrect. A is incorrect, because performance is not often the reason to prefer one to the other. Files.lines() reads the file in a lazy manner, while Files.readAllLines() reads the entire file into memory all at once; therefore Files.lines() works better on large files with limited memory available, and B is correct. Although a List can be converted to a stream with the stream() method, this requires an extra step; therefore C is correct since the resulting object can be chained directly to a stream. Finally, D and E are incorrect because they are not relevant to these methods. 
10- C, E. The REPLACE_EXISTING flag was not provided, so if the target exists, it will throw an exception at runtime and A is incorrect. Next, the NOFOLLOW_LINKS option means that if the source is a symbolic link, the link itself and not the target will be copied at runtime, so B is also incorrect. The option ATOMIC_MOVE means that any process monitoring the file system will not see an incomplete file during the move, so C is correct. D is incorrect, since you could rename a file not to have an extension. Note that in this example, if monkey.txt is a file, then the resulting /animals would be a file, not a directory. Likewise, if the source is a directory, the result would also be a directory. E is correct, because moving always preserves the metadata even if the COPY_ATTRIBUTES flag is not set. 
11- A. The code compiles and runs without issue, so C, D, E, and F are incorrect. Even though the file is copied with attributes preserved, the file is considered a separate file, so the output is false and A is correct and B is incorrect. Remember, isSameFile()returns true only if the files pointed to in the file system are the same, without regard to the file contents. 
12- A, F. For this question, you need to rule out the answers that can be used to obtain a Path instance. D and G both use the Paths.get() method, one with optional vararg values. C uses an overloaded version of Paths.get() that takes a URI. B is a longer form for getting a Path using a specific file system, in this case the default file system. Finally, E uses a method added to java.io.File to make it easily compatible with Path. The remaining choices A and F are the correct ones, because they call constructors on Path and FileSystem, respectively, instead of using the underlying factory methods. The rest are invalid since they do not use the factory methods to gain access to instances. 
13- B. The code compiles and runs without issue, so C, D, E, F, and G are incorrect. Note that the sample code creates a stream, collects it as a list, and then converts it back to a stream before outputting the filenames. The key here is that the depth parameter specified as the second argument to find() is 0, meaning the only record that will be searched is the top-level directory. Since we know that the top directory is regular and not a symbolic link, no other paths will be visited and nothing will be printed. For these reasons, B is the correct answer and A is incorrect. 
14- E. First off, recall that the java.io.File.listFiles() method retrieves the members of the current directory without traversing any subdirectories. The methods Path.listFiles() and Files.files() do not exist, so A and D are incorrect. Files.walk() and Files.find() recursively traverse a directory tree rather than list the contents of the current directory; therefore, they are not a close match, and B and C are incorrect. Note that you could use these methods to perform the same operation if you set the depth limit to 1 and used a lambda with Files.find() that always returns true, but the question was about which method is most similar to java.io.File.listFiles(). In that regard, Files.list() is the closest match since it always reads only a single directory, and E is correct. Note that instead of an array, a stream of Path values is returned. Finally, F is incorrect because it reads the contents of a file, not a directory.
15- D, E, F. Whether a path is a symbolic link, file, or directory is not relevant, so A and C are incorrect. Using a view to read multiple attributes leads to fewer round-trips between the process and the file system and better performance, so D and F are correct. For reading single attributes, there is little or no expected gain, so B is incorrect. Finally, views can be used to access file system–specific attributes that are not available in java.nio.Files methods; therefore E is correct. 
16- F. The code compiles without issue, so B, C, and D are incorrect. The code snippet breaks a file into lines and then further separates the lines by commas using the flatMap() method. The result is printed with one entry on a single line, but all original line breaks and commas from the file are removed; therefore F is correct. Since we are told that the file is non-empty and regular, and the program has access to read it, A and E are incorrect. 
17- A, G. The code compiles without issue, so B, C, and D are incorrect. The first line actually resolves to the root path since .. and getParent()are conceptually equivalent. Therefore, G is correct and E and F are incorrect. A is also correct since it may encounter a file that it does not have access to read, which is common when trying to read an entire file system. 
18- D. The code compiles and runs without issue, so F is incorrect. The one thing to notice about these paths is that they represent the same path within the file system. Therefore, isSameFile() would return true and B and C are incorrect. The second output is false, because Path.equals() does not resolve the path within the file system, so A is incorrect. Finally, the normalized paths are equals(), since all extra symbols have been removed; therefore D is correct and E is incorrect. 
19- A, C, E. While all of the answers are applicable to the NIO.2, only A, C, and E are options that are not supported by the legacy java.io.File class and therefore give NIO.2 an advantage over java.io.File. 
20- B. The normalize() method does not convert a relative path into an absolute path; therefore, the path value after the first line is just the current directory symbol. The for() loop iterates the name values, but since there is only one entry, the loop terminates after a single iteration. Therefore, B is correct and the rest of the answers are incorrect.    