1- B. The answer needs to implement List because the scenario allows duplicates. Since you need a List, you can eliminate C, D, and E immediately. HashMap is a Map and HashSet is a Set. LinkedList is both a List and a Queue. You want a regular List. Option A, Arrays, is trying to distract you. It is a utility class rather than a Collection. An array is not a collection. By process of elimination, the answer is B. 
2- D. The answer needs to implement Map because you are dealing with key/value pairs per the unique string text. You can eliminate A, C, E, and F immediately. ArrayList and Vector are Lists. HashSet and TreeSet are Sets. Now it is between HashMap and TreeMap. Since the question talks about ordering, you need the TreeMap. 
3- E. The code does not compile. It attempts to mix generics and legacy code. Lines 3 through 7 create an ArrayList without generics. This means that we can put any objects in it. Line 7 should be looping through a list of Objects rather than Strings since we didn’t use generics. 
4- E. Since we call push() rather than offer(), we are treating the ArrayDeque as a LIFO (last-in, first-out) stack. On line 7, we remove the last element added, which is "ola". On line 8, we look at the new last element ( "hi"), but don’t remove it. Lines 9 and 10, we remove each element in turn until none are left. Note that we don’t use an Iterator to loop through the ArrayDeque. The order in which the elements are stored internally is not part of the API contract. 
5- B, C, F. Option A does not compile because the generic types are not compatible. We could say HashSet<? extends Number> hs2 = new HashSet<Integer>();. Option B uses a lower bound, so it allows superclass generic types. Option C is a traditional use of generics where the generic type is the same and the List type uses the interface as the type. Option D does not compile because a Set is not a List. Option E does not compile because upper bounds are not allowed when instantiating the type. Finally, Option F does compile because the upper bound is on the correct side of =. 
6- C. Line 7 gives a compiler warning for not using generics but not a compiler error. Line 4 compiles fine because toString() is defined on the Object class and is therefore always available to call. Line 6 creates the Hello class with the generic type String. Line 7 creates the Hello class with the generic type Object since no type is specified. 
7- A, D. The code compiles fine. It uses the diamond operator, and it allows any implementation of Number to be added. HashSet does not guarantee any iteration order, making A and D correct. 
8- C. TreeSet sorts the elements. Since uppercase letters sort before lowercase letters, the ordering is "ONE", "One", "one". The ceiling() method returns the smallest element greater than the specified one. "On" appears between "ONE" and "One". Therefore, the smallest element that is larger than the specified value is "One". 
9- E. Trick question! The Map interface uses put() rather than add() to add elements to the map. If these examples used put(), the answer would be A and C. B is no good because a long cannot be shoved into a Double. D is no good because a char is not the same thing as a String. 
10- A. The array is sorted using MyComparator, which sorts the elements in reverse alphabetical order in a case-insensitive fashion. Normally, numbers sort before letters. This code reverses that by calling the compareTo() method on b instead of a. 
11- A. Line 3 uses the diamond operator to create the map. Lines 5 and 7 use autoboxing to convert between the int primitive and the Integer wrapper class. The keys map to their squared value. 1 maps to 1, 2 maps to 4, 3 maps to 9, 4 maps to 16, and so on. 
12- A, B, D. The generic type must be Exception or a subclass of Exception since this is an upper bound. C and E are wrong because Throwable is a superclass of Exception. D uses an odd syntax by explicitly listing the type, but you should be able to recognize it as acceptable. 
13- B, E. showSize() can take any type of List since it uses an unbounded wildcard. Option A is incorrect because it is a Queue and not a List. Option C is incorrect because the wildcard is not allowed to be on the right side of an assignment. Option D is incorrect because the generic types are not compatible. Option B is correct because a lower-bounded wildcard allows that same type to be the generic. Option E is correct because Integer is a subclass of Number. Vector is an old type of List. It isn’t common in new code, but you still need to know it for the exam and in case you encounter old code. 
14- C. This question is hard because it defines both Comparable and Comparator on the same object. t1 doesn’t specify a Comparator so it uses the Comparable object’s compareTo() method. This sorts by the text instance variable. t2 did specify a Comparator when calling the constructor, so it uses the compare() method, which sorts by the int. 
15- D. The list is sorted in descending order. However, it is searched using the default order, which is sorted in ascending order. binarySearch() requires both to use the same sort order. Therefore, the precondition for binarySearch() is not met and the result is undefined. 
16- B, D, F. The java.lang.Comparable interface is implemented on the object to compare. It specifies the compareTo() method, which takes one parameter. The java.util.Comparator interface specifies the compare() method, which takes two parameters. 
17- B, D. Line 1 is a generic class that requires specifying a name for the type. Options A and C are incorrect because no type is specified. Line 3 tries to use the diamond operator to instantiate the class. Option E is incorrect because T is not a class and certainly not one compatible with String. Option F is incorrect because a wildcard cannot be specified on the right side when instantiating an object. 
18- A, B. C is both a class and a type parameter. This means that within the class D, when we refer to C, it uses the type parameter. All of the choices that mention class C are incorrect because it no longer means the class C. 
19- A, D. A LinkedList implements both List and Queue. The List interface has a method to remove by index. Since this method exists, Java does not autobox to call the other method. Queue has only the remove by object method, so Java does autobox there. Since the number 1 is not in the list, Java does not remove anything for the Queue. 
20- E. This question looks like it is about generics, but it’s not. It is trying to see if you noticed that Map does not have a contains() method. It has containsKey() and containsValue() instead. If containsKey() was called, the answer would be false because the 123 in the list is an Integer rather than a String.
21- A, F. You have to memorize this. hasNext() returns a boolean, and it is used in the loop. next() returns the next element. 
22- B. When using generic types in a static method, the generic specification goes before the return type. 
23- B, E. Both Comparator and Comparable are functional interfaces. However, Comparable is intended to be used on the object being compared, making choice B correct. removeIf was added in Java 8 to allow specifying the lambda to check when removing elements, making choice E correct. 
24- F. Choice A is incorrect because forEach takes a Consumer parameter, which requires one parameter. Choices B and C are close. The syntax for a lambda is correct. However, s is already defined as a local variable and therefore the lambda can’t redefine it. Choices D and E use incorrect syntax for a method reference. Choice F is correct. 
25- F. The first call to merge() calls the mapping function and adds the two numbers to get 13. It then updates the map. The second call to merge() sees that the map currently has a null value for that key. It does not call the mapping function but instead replaces it with the new value of 3. Therefore choice F is correct. 