1- D, F. There is no such class as ParallelStream, so A and E are incorrect. The method defined in the Stream class to create a parallel stream from an existing stream is parallel(); therefore F is correct and C is incorrect. The method defined in the Collection class to create a parallel stream from a collection is parallelStream(); therefore D is correct and B is incorrect. 
2- A, C, D, F. Runnable and Callable statements both take no method arguments as input, so B is incorrect. Runnable returns void and Callable returns a generic type, so F is correct, and E and G are incorrect. All methods are capable of throwing unchecked exceptions, so A is correct. Only Callable is capable of throwing checked exceptions, so C is correct. Both Runnable and Callable can be implemented with lambda expressions, so D is correct. 
3- B, C. The code does not compile, so A and F are incorrect. The first problem is that although a ScheduledExecutorService is created, it is assigned to an ExecutorService. Since scheduleWithFixedDelay() does not exist in ExecutorService, line w1 will not compile, and B is correct. The second problem is that scheduleWithFixedDelay()supports only Runnable, not Callable, and any attempt to return a value is invalid in a Runnable lambda expression; therefore line w2 will also not compile and C is correct. The rest of the lines compile without issue, so D and E are incorrect.
4- C. The code compiles and runs without throwing an exception or entering an infinite loop, so D, E, and F are incorrect. The key here is that the increment operator ++ is not atomic. While the first part of the output will always be 100, the second part is nondeterministic. It could output any value from 1 to 100, because the threads can overwrite each other’s work. Therefore, C is the correct answer and A and B are incorrect. 
5- D. Livelock occurs when two or more threads are conceptually blocked forever, although they are each still active and trying to complete their task. A race condition is an undesirable result that occurs when two tasks are completed at the same time, which should have been completed sequentially. For these reasons, D is the only correct answer. 
6- B. If a task is submitted to a thread executor, and the thread executor does not have any available threads, the call to the task will return immediately with the task being queued internally by the thread executor. For this reason, B is the only correct answer. 
7- A. The code compiles without issue, so D is incorrect. The CopyOnWriteArrrayList class is designed to preserve the original list on iteration, so the first loop will be executed exactly three times and E is incorrect. The ConcurrentSkipListSet class allows modifications while iterating, so it is possible that the second loop could generate an infinite loop. In this case, though, the second loop executes exactly four times, since elements in a set are unique and 5 can be added only once. For these reasons, F and G are also incorrect. Finally, despite using the elements of l1 to populate the collections, l2 and s3 are not backed by the original list, so the size of l1 is 3. Likewise, the size of l2 is 6 and the size of s3 is 4, so A is the correct answer. 
8- G. The code compiles and runs without issue, so C, D, E, F, and H are incorrect. There are two important things to notice: first,  