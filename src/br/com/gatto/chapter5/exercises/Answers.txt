1- A, B. Choices E and F are incorrect because a Locale is created using a constructor. The convention is to use lowercase for a language code and uppercase for a country code. The language is mandatory when using a constructor, which makes choices A and B correct. 
2- C, D, E. Localization refers to user-facing elements that a user sees. Currency, dates, and numbers are commonly used in different formats for different countries. Class and variable names are internal to the application, so there is no need to translate them for users. Booleans are true/false values with standard names. 
3- C, D. Choice A is incorrect because Java will look at parent bundles. For example, Java will look at Props.properties if Props_en.properties does not contain the requested key. Java class resource bundles can have non-String values while property files are limited to strings. Therefore, choice B is incorrect and choice C is correct. Choice D is correct because the locale is only changed in memory. Choice E is incorrect because Java specifies that it will look for a Java class resource bundle before a property file of the same name. 
4- B. Java will first look for the most specific matches it can find, starting with Dolphins_en_US.java and then Dolphins_en_US.properties. Since neither is found, it drops the country and looks for Dolphins_en.java. Since a match is found, there is no reason to go on to the next one, which is Dolphins_en.properties. 
5- D. Java will use Dolphins_fr.properties as the matching resource bundle on line 7 because it is an exact match on the language of the requested locale. Line 8 finds a matching key in this file. Line 9 does not find a match in that file, and therefore it has to look higher up in the hierarchy. Once a bundle is chosen, only resources in that hierarchy are allowed. 
6- D, F. Options A and B are incorrect because LocalDate does not have a public constructor. Option C is incorrect because months start counting with 1 rather than 0. Option E is incorrect because it uses the old Calendar constants for months, which begin with 0. Options D and F are both correct ways of specifying the desired date. 
7- D. A LocalDate does not have a time element. Therefore, it has no method to add hours, and the code does not compile. 
8- F. Java throws an exception if invalid date values are passed. There is no 40th day in Aprilâ€”or any other month for that matter. 
9- B. The date starts out as April 30, 2018. Since dates are immutable and the plus methods have their return values ignored, the result is unchanged. Therefore, Option B is correct. 
10- E. Even though d has both date and time, the formatter only outputs time. 
11- B. Period does not allow chaining. Only the last Period method called counts, so only the two years are subtracted. 
12- A, E. When dealing with time zones, it is best to convert to GMT first by subtracting the time zone. The first date/time is 9:00 GMT, and the second is 15:00 GMT. Therefore, the first one is earlier by 6 hours. 